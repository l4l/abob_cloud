# Описание сервиса AbobCloud

Сервис представляет собой облачное хранилище фотографий, которые содержат в себе флаг, зашитый с помощью стеганографии. Особенность его в том, что сервис имеет "истекшую лицензию" и просит ввести ключ, что требует предварительное исследование для запуска.


# Флаг

Имеет размер `FLAG_SIZE` (_common.h_). Получается путем нехитрой свертки матрицы пикселей с помощью ксора (_flag.c_)


# Протокол

Общение с сервисом происходит с помощью UDP и TCP пакетов.

Команды:

- Отправить png изображение (TCP)
- Получить флаг по хэшу (UDP)
- Проверить, есть ли флаг (UDP)


# Основной флоу для сервиса

## Push

|   From -> To       |  Action                                                                   |
|-------------------:|--------------------------------------------------------------------------:|
|    jury -> service |   Send image __Img__                                                      |
| service -> service |   Save __Img__ it to DB: `INSERT INTO imgs VALUES(Hash PRIMARY, Img)`     |

## Pull

|   From -> To       |  Action                                                    |
|-------------------:|-----------------------------------------------------------:|
|    jury -> service |   Request __Img__ by its hash `H(Img)`                     |
| service -> service |   Find __Img__ in DB, calculate flag from it: `F=f(Img)`   |
| service -> jury    |   Send __F__                                               |
|    jury -> jury    |   Check flag `F == F_orig`                                 |


# License key

Сервис требует лицензионный ключ для своей работы. Загрузчик просит бинарный ключ размером `KEY_SIZE` (вводится в виде хекс-строки). Этот ключ далее используется для расшифровки исполняемого файла. Сам загрузчик проверяет ключ с магическими числами на следующие характеристики:

- Побайтовый ксор
- Побайтовая сумма
- Побайтовый ксор по модулю 1337

После того, как характеристики совпадут, то загрузчик ксорит исполяемый файл находящийся в одной из секций и распаковывает его в /tmp/abob_cloud. _TODO_: запуск + удаление исполняемого файла после завершении работы лоадера.

Ленивый конечно же эти уравнения решать не будет (если они вообще решаются за вменяемое время) и просто переберет все валидные значения ELF-заголовка.


# Уязвимости

## Buffer Over-read в flag.c:retrieve\_flag

В функции высчитывается флаг путем ксора матрицы пикселей картинки. При этом проверяется, что она имеет размер `FLAG_SIZE*FLAG_SIZE`. Однако еще делается не проверяющееся предположение о том, что картинка имеет глубину цвета 32 бита. Соответственно при проходе в не зависимости от типа картинки будет доступ к `FLAG_SIZE * FLAG_SIZE * 4` байтам. Подсунунув картинку с глубиной цвета 16 бит, можно проксорить флаг с дополнительными `FLAG_SIZE * FLAG_SIZE * 2` байтами после картинки. Поскольку флаг хранится в первом поле `struct Image`, то его можно без труда восстановить.

### Фиксики

Один из самых простых способов починить эту багу, это попросту дропать пакеты на файрволе с udp-пакетами не равными 9332 байт.

Вариант чуть посложнее, но более надежен - сделать дополнительную проверку на глубину цвета.

## SQLi в img\_db.c:db\_search

Баг в том, что SELECT запрос проверяет валидность хэша не сравнением, а с помощью LIKE. Тем самым можно пробрутить хэши и получить картинки, поскольку "%" проходит проверку на валидный хэш (isgraph)

### Фиксики

Тривиальный фикс: подмена вызова isgraph -> isalnum

Чуть сложнее: фильтрация по сигнатурам

## Something net.c:handle_upload

TODO

## Потенциальные уязвимости (it's a feature!)

На i/o и кэш нет синхронизации, так что вполне может быть что-то выйти
